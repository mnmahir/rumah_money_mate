generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                 String             @id @default(uuid())
  username           String             @unique
  email              String             @unique
  password           String
  displayName        String
  isAdmin            Boolean            @default(false)
  isDeleted          Boolean            @default(false)  // Soft delete flag
  deletedAt          DateTime?          // When the user was deleted
  bankName           String?
  bankAccountNo      String?
  bankAccountName    String?
  paymentQrImage     String?
  avatarUrl          String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  deleteApprovals    DeleteRequest[]    @relation("DeleteApprovedBy")
  deleteRequests     DeleteRequest[]    @relation("DeleteRequestedBy")
  expensesCreatedFor Expense[]          @relation("ExpenseCreatedBy")
  expenses           Expense[]
  paymentsCreatedFor Payment[]          @relation("PaymentCreatedBy")
  paymentsReceived   Payment[]          @relation("PaymentTo")
  paymentsMade       Payment[]          @relation("PaymentFrom")
  recurringExpenses  RecurringExpense[]
  refreshTokens      RefreshToken[]
  splitBillItems     SplitBillItem[]
  expenseSplits      ExpenseSplit[]
}

model Category {
  id        String    @id @default(uuid())
  name      String    @unique
  icon      String?
  color     String?
  isDefault Boolean   @default(false)
  isDeleted Boolean   @default(false)  // Soft delete flag
  deletedAt DateTime? // When the record was deleted
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expenses  Expense[]

  @@index([isDeleted])
}

model Expense {
  id                 String            @id @default(uuid())
  description        String
  amount             Float             // Consider PostgreSQL with Decimal for production
  currency           String            @default("MYR")     // ISO 4217 currency code
  usage              Float?            // For utilities: usage amount (kWh, mÂ³, etc.)
  date               DateTime          @default(now())
  receiptImage       String?
  notes              String?
  isLocked           Boolean           @default(false)  // Locked records cannot be edited/deleted
  isDeleted          Boolean           @default(false)  // Soft delete flag
  deletedAt          DateTime?         // When the record was deleted
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  userId             String            // Who this expense is assigned to (primary payer)
  createdById        String?
  categoryId         String?
  recurringExpenseId String?
  recurringExpense   RecurringExpense? @relation(fields: [recurringExpenseId], references: [id])
  category           Category?         @relation(fields: [categoryId], references: [id])
  createdBy          User?             @relation("ExpenseCreatedBy", fields: [createdById], references: [id])
  user               User              @relation(fields: [userId], references: [id])
  splits             ExpenseSplit[]    // Split details for this expense

  @@index([userId, date])
  @@index([categoryId])
  @@index([isDeleted])
}

// Tracks how an expense is split among members
model ExpenseSplit {
  id        String   @id @default(uuid())
  expenseId String
  userId    String   // Who owes this portion
  amount    Float    // Amount this user owes
  createdAt DateTime @default(now())
  expense   Expense  @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([expenseId])
}

model Payment {
  id           String    @id @default(uuid())
  amount       Float     // Consider PostgreSQL with Decimal for production
  currency     String    @default("MYR")     // ISO 4217 currency code
  description  String?
  receiptImage String?   // Optional based on requirePaymentReceipt setting
  date         DateTime  @default(now())
  status       String    @default("pending")
  isLocked     Boolean   @default(false)  // Locked records cannot be edited/deleted
  isDeleted    Boolean   @default(false)  // Soft delete flag
  deletedAt    DateTime? // When the record was deleted
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  fromUserId   String
  toUserId     String
  createdById  String?
  createdBy    User?     @relation("PaymentCreatedBy", fields: [createdById], references: [id])
  toUser       User      @relation("PaymentTo", fields: [toUserId], references: [id])
  fromUser     User      @relation("PaymentFrom", fields: [fromUserId], references: [id])

  @@index([fromUserId])
  @@index([toUserId])
  @@index([status])
  @@index([isDeleted])
}

model SplitBill {
  id             String          @id @default(uuid())
  title          String
  totalAmount    Float           // Consider PostgreSQL with Decimal for production
  currency       String          @default("MYR")     // ISO 4217 currency code
  taxAmount      Float           @default(0)
  taxPercent     Float?
  serviceCharge  Float           @default(0)
  servicePercent Float?
  date           DateTime        @default(now())
  receiptImage   String?
  notes          String?
  categoryId     String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  items          SplitBillItem[]

  @@index([date])
}

model SplitBillItem {
  id          String    @id @default(uuid())
  description String
  amount      Float     // Consider PostgreSQL with Decimal for production
  quantity    Int       @default(1)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  splitBillId String
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  splitBill   SplitBill @relation(fields: [splitBillId], references: [id], onDelete: Cascade)

  @@index([splitBillId])
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Settings {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RecurringExpense {
  id                 String    @id @default(uuid())
  description        String
  amount             Float     // Consider PostgreSQL with Decimal for production
  currency           String    @default("MYR")     // ISO 4217 currency code
  frequency          String
  startDate          DateTime
  endDate            DateTime?
  totalOccurrences   Int?
  occurrencesCreated Int       @default(0)
  nextDueDate        DateTime
  isActive           Boolean   @default(true)
  splitEqually       Boolean   @default(true)  // Whether to split among all active members
  splitType          String    @default("equal") // equal, percentage, amount
  splitConfig        String?   // JSON: Array of {userId, percentage?, amount?} for custom splits
  notes              String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  userId             String
  categoryId         String?
  expenses           Expense[]
  user               User      @relation(fields: [userId], references: [id])

  @@index([nextDueDate])
  @@index([isActive])
  @@index([userId])
}

model DeleteRequest {
  id            String   @id @default(uuid())
  recordType    String
  recordId      String
  reason        String?
  status        String   @default("pending")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  requestedById String
  approvedById  String?
  approvedBy    User?    @relation("DeleteApprovedBy", fields: [approvedById], references: [id])
  requestedBy   User     @relation("DeleteRequestedBy", fields: [requestedById], references: [id])

  @@index([status])
  @@index([recordType, recordId])
}
